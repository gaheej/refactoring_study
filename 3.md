# 코드에서 나는 악취

## 3.1 기이한 이름

* 코드는 단순 명료하게 작성해야 하고 이름은 코드를 명료하게 표현하는데 가장 중요한 요소
* 이름짓기는 프로그램밍에서 가장 어렵기로 손꼽히는 두가지 중 하나 (필 칼튼 -  캐시 무효화 , 이름짓기)
* 이름만 보고도 무슨 일을 하고 어떻게 사용해야 하는지 알 수 있도록 지어야 함
* 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 있다

## 3.2 중복 코드

- **함수 추출하기**
- **문장 슬라이스** 후 함수 추출하기
- 서브클래스들에 코드 중복시 **메서드 올리기**

## 3.3 긴 함수

* 짧은 함수의 간접호출 효과 - 코드를 이해하고 공유하고 선택하기 쉬워짐
* 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름
* 함수 이름은  동작방식이 아닌 의도가 드러나게 짓는다.
* 함수를 짧게 만드는 작업의 90%는 **함수 추출하기**
* 매개변수와 임시변수를 많이 사용한다면 
  * **임시변수를 질의 함수로 바꾸기**
  * **매개변수 객체 만들기**
  * **함수를 명령으로 바꾸기**
* 추출할 코드 덩어리 찾아내기
  * 주석을 참고
  * 조건문이나 반복문
    * **조건문 분해하기**
    * switch문의 case문 마다 **함수추출하기**
    * 같은 조건을 기준으로 나뉘는 switch문이 여러개라면 **조건부 로직을 다형성으로 바꾸기**
    * **반복문 쪼개기**

## 3.4 긴 매개변수 목록

* **매개변수를 질의 함수로 바꾸기**
* **객체를 통째로 넘기기** : 사용중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수를 전달시에 원본 데이터 구조를 통째로
* **매개변수 객체 만들기** : 항상 함께 전달되는 매개변수
* **플래그 이이수 제거하기** : 함수의 동작방식을 정하는 플래그 역할의 매개변수

## 3.5 전역 데이터

* 전역변수는 값을 누가 바꾸었는지 찾아낼 메커니즘이 없다는 게 문제
* 클래스 변수와 싱글톤에서도 같은 문제가 발생
* 대표적인 리팩터링 - **변수 캡슐화하기**
  * 데이터를 함수로 감싸 뎅터를 수정하는 부분을 쉽ㅁ게 찾을 수 있고 접근을 통제할 수 있게 됨
  * 클래스나 모듈에 집어 넣고 그 안에서만 사용할 수 있도록 접근범위를 최소화 

## 3.6 가변 데이터

* 데이터의 변경은 예상치 못한 결과나 골치아픈 버그로 이어지는 경우가 종종있다.
* 이런 이유로 함수형 프로그래밍에서는 데이터는 절대 변경하지 않고 데이터를 변경하려면 복사본을 반환
  * 함수형언어가 프로그래밍에서 차지하는 비중이 적음
* 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.
  * **변수 캡슐화하기**
  * **변수쪼개기** - 하나의 변수에 다른 용도의 값을 저장하려고 값을 갱신하는 경우
  * **질의함수와 변경함수 분리하기**
    * **문장슬라이스 하기**
    * **함수 추출하기**
  * **세터 제거하기**
  * **파생변수를 질의함수로 바꾸기**
  * 가변데이터의 유효범위가 넓어질 수록 위험도 커짐
    * **여러 함수를 클래스로 묶기** 나 **여러 함수를 변환함수로 묶기**
    * 구조체 처럼 내부 필들에 데이터를 담고 있는 변수라면 **참조를 값으로 바꾸기** 적용
      * 내부필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

## 3.7 뒤엉킨 변경

* 뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타남
  * 하나의 모듈이 서로 다른 이유들로 인해 여러가지 방식으로 변경되는 일이 많을 때 발생
* 순차적으로 실행되는 것이 자연스러운 맥락이라면 **단계쪼개기**
* 전체 처리 과정 곳곳에서 다른 맥락의 함수가 호출되는 빈도가 높다면 적당한 모듈을 만들어 **<u>관련 함수들을 모은다</u>**
  * **함수 옮기기**
  * 여러 맥락에 관여하는 함수가 있다면 옮기기 전에 함수추춣하기
  * 모듈이 클래스라면  클래스 추출하기 

## 3.8 산탄총 수술

* 산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대

* 변경할 부분이 코드 전반에 퍼져있다면 찾기 어렵고 꼭 수정해야할 부분을 놓치지 쉬움

* 함께 변경되는 대상들을 **함수 옮기기**와 **필드 옮기기**로 한 모듈에 묶기

* 비슷한 데이터를 다루는 함수가 많다면 **여러 함수를 클래스로 묶기**

* 데이터 구조를 변환하거나 보강하는 함수들에는 **여러함수를 변환 함수로 묶기**

* 이렇게 묶은 함수들의 출력결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 **단계 쪼개기** 적용 

* 뒤엉킨 변경과 산탄총 수술

  * 공통점

    * 원인 :  맥락을 잘 구분하지 못함
    * 해법 : 맥락을 명확히 구분

  * 차이점

    * 발생과정(현상) 
      * 뒤엉킨 변경 : 한 코드에 섞여 들어감
      * 산탄총 수술 : 여러 코드에 흩뿌려짐

    *  해법(실제행동)
      * 뒤엉킨 변경 : 맥락별로 분리
      * 산탄총 수술 : 맥락별로 모음

## 3.9 기능 편애

* 프로그램의 모듈화
  * 코드를 여러 영역으로 나눔
    * 영역안에서 이뤄지는 상호작용은 최대한 늘림
    * 영역사이에서 이뤄지는 상호작용은 최소로 줄임 
* 기능편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터 보다  다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때
*  **함수 옮기기**
* 함수의 일부에서만 기능을 편애 할 때
  * **함수 추출하기** 후 **함수옮기기**
* 어디로 옮길지 명확하지 않으면 
  * 가장 많은 데이터를 포함한 모듈로 옮김
  * 함수를 **함수 추출하기** 로 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮김
  * 앞의 두 문단에서 설명한 규칙을 거스르는 복잡한 패턴
    * 예로 [전략 패턴](https://victorydntmd.tistory.com/292) 과 [방문자 패턴](https://dailyheumsi.tistory.com/216) 및 켄트백의 자기위임 
      * 뒤엉킨 변경 냄새를 없앨 때 활용하는 패턴
      * 원칙은 *함께 변경할 대상을 한데 모으는 것*
    * 데이터와 이를 활용하는 동작은 함께 변경해 야 할 때가 많지만 예외가 존재함
      * 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다
      * 전략 패턴과 방문자 패턴을 적용하면 오버라이드 해야할 소량의 동작코드를 각각의 클래스로 격리해 주므로 수정하기 쉬워짐. (대신 간접호출이 늘어난다)

## 3.10 데이터 뭉치

* 데이터 항목들 서너개가 여러 곳에 항상 뭉쳐다니는 모습을 흔히 목격
  * 클래스두어 개의 필드에서 혹은 여러 메서드의 시그니쳐에서 함께 발견됨
* 먼저 필드 형태의 데이터 뭉치는  **클래스 추출하기** 적용
* 다음 메서트 시그니처에 있는 데어터 뭉치는 먼저 **매개변수 객체 만들기** 나 **객체 통째로 넘기기** 를 적용
* 데이터 뭉치인지 판별하려면 값 하나를 삭제시 나머지 데이터만으로는 의미가 없다면 데이터 뭉치
* 위에서 레코드 구조가 아닌 클래스 만들기를 권장하였음
  * 기능 편애를 없애는 과정에서 새로운 클래스로 옮기면 좋은 동작이 없는지 확인
  * 이러한 연계과정은 상당한 중복을 없애고 유용한 클래스를 탄생시키는 결과로 이어짐
  * 데이터 뭉치가 생산성에 기여하는 정식 멤버로 등극

## 3.11 기본형 집착(기본타입에 대한 강박관념)

* 문자열을 다루는 코드에서 특히 흔하다
* 기본형을 객체로 바꾸기
* 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입코드로 쓰였다면
  * **타입코드를 서브클래스로 바꾸기** 와 **조건부 로직을 다형석으로 바꾸기** 를 차례로 적용
* 자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치 (**클래스 추출하기** 와 **매개변수 객체만들기** 이용)

## 3.12 반복되는 switch문

* 순수한 객체 지향을 신봉하는 사람들과 이야기하다 보면 주제는 스위치 문의 사악함으로 흘러가기 마련
  * 스위치 문을 모조리 조건부 로직을 다형성으로 바꾸기로 없애야 한다고 주장
  * 심지어 모든 조건부 로직을 다형성으로 바꾸어 if문도 휴지통으로 쓸어 담아야 한다고 주장하는 이도 있음
* 이 책의 초판에 스위치 문의 냄새를 소개한 이유
  * 1990년대 후반까지도 다형성의 가치를 제대로 아는 사람이 적었음
  * 스위치문 냄새가 다형성을 이용하도록 전환하는데 도움이 되었음
* 지금은 다형성이 널리 자리를 잡아 단순히 스위치문을 썼다고 리팩토링의 검토 대상이 되지는 않음
* 문자열등 복잡한 타입까지 지원하는 발전된 스위치문을 제공하는 언어도 많아졌다.
* 이제는 똑같은 조건부 로직이 여러 곳에 등장하는 코드에 집중
  * 중복된 스위치문이 문제가 되는 이유는 케이스가 추가할때 마다 다른 스위치문들도 모두 찾아 함께 수정해야 함
  * 이럴 때 다형성은 반복된 스위치문이 내뿜는 사악한 기운을 제압하여 최신 스타일로 바꿔주는 세련된 무기임

## 3.13 반복문

* 반복문은 프로그래밍 언어가 등장할 때부터 함께한 핵심 프로그래밍 요소
* 지금은 일급함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기를 적용하여 반복문을 제거
* 필터나 맵 같은 파이프라인 연산을 사용하면 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있음

## 3.14 성의 없는 요소

*  프로그래밍 요소 : 메서드,클래스,인터페이스 등 코드 구조를 잡는데 활옹디는 요소
* 불필요한 프로그래밍 요소는 제거
  * **함수 인라인 하기**
  * **클래스 인라인 하기**
  * **계층 합치기**

## 3.15 추측성 일반화

* 나중에 필요할 거야라는 생각으로 작성해 둔 당장은 필요없는 코드 삭제
  * 거의 하는 일이 없는 추상클래스는 **계층 합치기** 로 제거
  * 쓸데없이 위임하는 코드는 **함수 인라인 하기** 나 **클래스 인라인 하기** 로 삭제
  * 본문에서 사용되지 않는 매개변수는 **함수 선언 바꾸기** 로 제거
  * 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스는 테스트 케이스부터 삭제후 **죽은 코드 제거하기** 

## 3.16 임시 필드

* 간혹 특정 상황에서만 값이 설정되는 필드를 가지는 클래스도 있음
  * 객체를 가져올 때  당연히 모든 필드가 채워져 있으리라 기대하는 것이 보통
  * 이렇게 임시 필드를 갖도록 하면 코드를 이해하기 어려움
* 이렇게 덩그마니 떨어져 있는 필드들을 발견하면
  * **클래스 추출하기** 로 제 살 곳을 찾아 준 다음 **함수 옮기기** 로 임시필드들과 관련된 코드를 새 클래스로 몰아 넣는다.
  * 임시 필드들이 유효한지 확인후 동작하는 조건부 로직이 있을 때
    * **특이 케이스 추가하기** 로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거

## 3.17 메세지 체인

* 메세지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말함

* 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미하며 내비게이션 중간단계를 수정하면  클라이언트 코드도 수정해야 함

* **위임 숨기기** 로 해결

  * 체인을 구성하는 모든 객체에 적용하면 중간 객체들이 모두 중개자가 돼버리기 쉬움
  * 최종 객체가 어떻게 쓰이는지 부터 파악

* **함수 추출하기** 로 결과 체인을 사용하는 코드 일부를 따로 빼낸 다음 **함수옮기기** 로 체인을 숨길 수 있는 지 살펴보자

* 체인을 구성하는 객체 중 특정 하나를 사용하는 클라이언트 중 그 이후의 객체들도 사용하기를 원하는 클라이언트 들이 제법 된다면 이 요구를 처리해 줄 메서드를 추가한다.

* 예시

  `managerName = aPerson.department.manager.name;`

  `managerName  = aPerson.department.managerName; // 관리자 객체 존재를 숨김`

  `managerName = aPerson.manager.name; // 부서 객체의 존재를 숨김` 

  `managerName = aPerson.managerName; // 부서 객체와 관리자 객체 모두의 존재를 숨김`

  이 체인의 최종 결과 객체는 name이 반환하는 부서장의 이름이다. 이 객체가 다음처럼 쓰인다고 해보자

  `managerName = aPerson.department.manager.name`

  `Report = '${managerName}' 께` 

  ​				`${aPerson.name} 님의 작업 로그` 

  ​				`...'`

  `console.log(report)`

  여기서 보고서 생성로직을 함수로 추출한 다음 적당한 모듈로 옮기면 체인의 존재가 감추어 진다.

  `console.log(reportAutoGenerator.report(aPerson));`

  마지막으로 체인의 중간인 부서정보를 얻어 사용하는 다수의 클라이언트가 부서장 이름도 함께 사용한다면 부서 클래스에 managerName() 메서드를 추가하여 체인을 단축할 수 있다.

## 3.18 중개자

* 외부로부터 세부사항을 숨겨주는 캡슐화는 위임에 자주 활용됨
* 위임하는 메서드를 제거한 후 남는 일이 거의 없다는 호출하는 쪽으로 **함수 인라인하기**

## 3.19 내부자 거래

* 모듈사이에 데이터 거래가 많으면 결합도가 높아지므로 그 양을 최소로 줄이고 투명하게 처리해야 함
* 은밀히 데이터를 주고 받는  모듈들이 있다면 **함수 옮기기** 와 **필드 옮기기** 기법으로 떼어 놓는다.
* 여러 모듈이 같은 관심사를 공유한다면 공통부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 위임숨기기를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.
* 상속구조에서 부와 자식간에 결탁이 생길 때 **서브클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를 활용 

## 3.20 거대한 클래스

* 한 클래스가 너무 많은 일을 하면 필드수가 늘어나고 중복코드가 생기기 쉬움
* 클래스 추출하기 - 필드들 일부를 따로 묶는다.
* 이렇게 분리할 컴포넌트를 원래 클래스와 상속관계로 만드는게 좋다면 **슈퍼 클래스 추출하기** 나 **타입코드를 서브클래스로 바꾸기**를 적용하는 편이 쉽다.
* 코드량이 너무 많은 클래스도 그 클래스 안에서 자체적으로 중복을 제거
* 클라이언트들이 거대 클래스를 이용하는 패턴을 파악하여 특정한 기능 그룹만을 주로 사용하는지 살펴 각각의 기능 그룹이 개별 클래스로 추출될 후보임. 
* **클래스 추출하기, 슈퍼 클래스 추출하기, 타입코드를 서브클래스로 바꾸기** 등을 활용하여 여러 클래스로 분리

## 3.21 서로 다른 인터페이스의 대안 클래스들

* 클래스를 사용할 때 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것
* 교체룰 하려면 인터페이스가 같아야 함
* **함수 선언 바꾸기**로 메서드 시그니쳐를 일치
* **함수 옮기기**로 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
* 그러다 대안 클래스들 사이에 중복코드가 생기면 **슈퍼클래스 추출하기** 적용 고려

## 3.22 데이터 클래스

* 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스
  * Public 필드는 **레코드 캡슐화하기** 로 숨기자
  * 변경하면 안되는 필드는 **세터 제거하기**
  * 다른 클래스에서 데이터 클래스의 게터/세터를 사용하는 메서드를 함수 옮기기로 데이터 클래스로 옮길 수 있는 지 살펴보자
  * 통째로 옮기기 힘들다면 함수 추출하기로 옮길 수 있는 부분만 별도 메서드로 뽑아낸다.
  * 데이터 클래스는 필요한 동작이 엉뚱한 곳에서 정의돼 있다는 신호일 수 있음
    * 클라이언트 코드를 데이터 클래스로 옮기기
    * 예외로 다른 함수를 호출해 얻은 결과 레코드로는 동직코드를 넣을 이유가 없다. (예 단계 쪼개기 의 결롸로 나온 중간 데이터 구조가 있음)
    * 이런 데이터 구조는 불면이다. 불변 필드는 굳이 캡슐화 필요없이 게터를 통하지 않고 그냥 필드 자체를 공개해도 됨 

## 3.23 상속 포기

* 서브클래스가 부모의 상속을 원치 않거나 필요없다면 예젼에는 계층구조를 잘못 설계했기 때문으로 보았음
* 이런 관점에서의 해법은 먼저 같은 계층에 서브클래스를 하나 새로 만들고 메서드 내리기와 필드 내리기를 활용해 상속 받지 않은 부모 코드를 새로 만드 서브클래스로 넘긴다.
* 상속포기 시에 혼란과 문제가 생긴다면 위의 예전 방식을 따른다.
* 상속포기는 서브클래스가 부모 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을 때 발생
* 이럴 때는 **서브클래스를 위임으로 바꾸기** 나 **슈퍼클래스를 위임으로 바꾸기**를 활용

## 3.24 주석

* 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많음
* 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기** 를 적용해 본다
* 이미 추출된 함수임에도 설명이 필요하면 **함수 선언 바꾸기**로 함수 이름을 바꿔본다
* 시스템이 동작하는 선행조건을 명시하고 싶다면 **어서션 추가하기** 사용
* ***주석을 남겨야겠다는 생각이 들면 가정 먼저 주석이 필요없는 코드로 리팩터링 해본다***
* 뭘 할지 모를 때라면 주석을 달아두면 좋다 (현재 진행상황, 확실하지 않은 부분, 코드를 지금처럼 작성한 이유)
