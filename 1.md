# 리팩터링: 첫 번째 예시
## 1.1 자, 시작해보자.
- 다양한 연극을 외주로 받아 공연하는 극단이 있음.
- 극단은 비극(tragedy)과 희극(comedy)만 공연을 함
- 연극은 장르와 관객 규모를 기초로 비용 책정
- 공연료와 별개로 포인트(volume credit)을 지급, 다음 의뢰 시 공연료를 할인 받을 수 있음

- 공연할 연극 정보 (play.json)
```JSON
{
    "hamlet": {"name": "Hamlet", "type": "tragedy"},
    "as-like": {"name": "As You Like It", "type": "comedy"},
    "othello": {"name": "Othello", "type": "tragedy"},
}
```

- 공연료 청구서 데이터 (invoices.json)
```JSON
[
    {
        "customer": "BigCo",
        "performances": [
            {
                "playID": "hamlet",
                "audience": 55
            },
            {
                "playID": "as-like",
                "audience": 35
            },
            {
                "playID": "othello",
                "audience": 40
            }
        ]
    }
]
```

- 공연료 청구서를 출력하는 코드
```JavaScript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    // Intl.NumberFormat : 숫자 서식을 지원하는 객체
    const format = new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format;

    for (let perf of invoice.performances) {
        const play = plays[perf.playID];
        let thisAmount = 0;

        switch (play.type) {
            case "tragedy": // 비극
                thisAmount = 40000;
                if (perf.audience > 30) {
                    thisAmount += 1000 * (perf.audience - 30);
                }
                break;

            case "comedy": // 희극
                thisAmount = 30000;
                if (perf.audience > 20) {
                    thisAmount += 10000 + 500 * (perf.audience - 20);
                }
                thisAmount  += 300 * perf.audience;
                break;
            
            default: 
                throw new Error(`알 수 없는 장르: ${play.type}`)
        }

        // 포인트 적립
        volumeCredits += Math.max(perf.audience - 30, 0);
        // 희극 관객 5명마다 추가 포인트를 제공
        if ('comedy' === play.type) volumeCredits += Math.floor(perf.audience / 5);

        // 청구 내역을 출력
        result += `  ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)\n`;
        totalAmount += thisAmount;
    }

    result += `총액: ${format(totalAmount/100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- 실행 방법
    - 크롬 개발자 도구에 console 에 json 객체들 생성 후 함수 정의해주고 아래처럼 테스트
    - invoices.json의 경우 배열이기 때문에 `invoice = invoices[0]` 지정 후 사용
    ```JavaScript
    console.log(statement(invoice, play));
    ```
    - 다른 방법 : jsFiddle 사용 [링크](https://jsfiddle.net/)

## 1.2 예시 프로그램을 본 소감
- 글쓴이는 이 상태로도 그럭저럭 쓸 만 하다는 생각이 듦
- 글쓴이는 수백 줄짜리 코드를 수정할 때면 먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있게 코드를 여러 함수와 프로그램 요소로 재구성한다. 

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다. 

- 청구 내역을 html로 출력하는 기능 필요
    - html로 출력하기 위해서는 statement() 함수의 복잡도가 크게 증가
    - 복잡한 조건들이 추가되어 청구서 작성 로직을 변경할 때마다 기존 함수와 HTML 버전 함수 모두를 수정하고, 확인이 필요함
- 배우들은 여러가지 장르를 연기하고 싶어하는데, 이 변경 사항을 적용하기 위해서는 공연료와 적립 포인트 계산법에 영향을 줄 수 밖에 없음
- **결국엔 연극 장르와 공연료 정책이 달라질 때마다 statement() 함수의 수정이 필요함**
  - 여기서 리팩터링이 필요

## 1.3 리펙터링의 첫 단계
- 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드부터 마련
    1. statement() 함수는 문자열을 반환하기 때문에 다양한 장르의 공연들로 구성된 공연료 청구서 몇 개를 미리 작성하여 문자열 형태로 준비
    2. statement() 함수가 반환한 문자열과 준비해둔 정답 문자열을 비교
    3. 테스트 프레임워크를 이용해 모든 테스트를 단축키 하나로 실행할 수 있게 설정
- 테스트 결과를 보고하는 방식이 중요함
    - 정답과 동일할 경우 통과했다는 의미의 초록불을 표출, 실패할 경우 빨간불을 표출

> 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

# 1.4 statement() 함수 쪼개기
- switch 문부터 확인해보자

```Javascript
...
        switch (play.type) {
            case "tragedy": // 비극
                thisAmount = 40000;
                if (perf.audience > 30) {
                    thisAmount += 1000 * (perf.audience - 30);
                }
                break;

            case "comedy": // 희극
                thisAmount = 30000;
                if (perf.audience > 20) {
                    thisAmount += 10000 + 500 * (perf.audience - 20);
                }
                thisAmount  += 300 * perf.audience;
                break;
            
            default: 
                throw new Error(`알 수 없는 장르: ${play.type}`)
        }
...        
```

- switch 문을 살펴보면 한 번의 공연에 대한 요금을 계산하고 있음
- switch 문을 `amountFor(aPerformance)` 라는 함수로 추출
    - 이 과정을 **함수 추출하기** 라는 절차로 기록
- 함수로 추출했을 때 유효범위를 벗어나는 변수를 확인
    - 위 코드에서는 `perf, play, thisAmount` 가 이 변수에 속함 

- amountFor(aPerfomance) 함수 구현
```Javascript
// 값이 변경되지 않는 변수는 매개 변수로 전달
function amountFor(perf, play) {
    let thisAmount = 0;
    switch (play.type) {
        case "tragedy": // 비극
            thisAmount = 40000;
            if (perf.audience > 30) {
                thisAmount += 1000 * (perf.audience - 30);
            }
            break;

        case "comedy": // 희극
            thisAmount = 30000;
            if (perf.audience > 20) {
                thisAmount += 10000 + 500 * (perf.audience - 20);
            }
            thisAmount  += 300 * perf.audience;
            break;
        
        default: 
            throw new Error(`알 수 없는 장르: ${play.type}`)
    }

    // 함수 안에서 값이 바뀌는 변수 반환
    return thisAmount;
}
```

- 원래 코드에서 변경
```Javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    // Intl.NumberFormat : 숫자 서식을 지원하는 객체
    const format = new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format;

    for (let perf of invoice.performances) {
        const play = plays[perf.playID];
        let thisAmount = amountFor(perf, play);

        // 포인트 적립
        volumeCredits += Math.max(perf.audience - 30, 0);
        // 희극 관객 5명마다 추가 포인트를 제공
        if ('comedy' === play.type) volumeCredits += Math.floor(perf.audience / 5);

        // 청구 내역을 출력
        result += `  ${play.name}: ${format(thisAmount/100)} (${perf.audience}석)\n`;
        totalAmount += thisAmount;
    }

    result += `총액: ${format(totalAmount/100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- 곧바로 컴파일 후 테스트해서 실수한 게 없는지 확인
- 조금씩 변경하고 매번 테스트하는 것은 리펙터링 절차의 핵심

> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

- 지금 예에서는 amountFor()를 statement()의 중첩 함수(nested function)로 만들 수 있었다. 
    - 중첩 함수를 사용하면 바깥 함수에서 쓰던 변수를 새로 추출한 함수에 매개변수로 전달할 필요가 없어 편함
- **함수 추출하기**는 흔히 IDE에서 자동으로 수행해준다. 
- 이 후 변수 이름을 좀더 명확하게 변경한다. 

```Javascript
function amountFor(perf, play) {
    // let thisAmount > let result
    let result = 0;
    switch (play.type) {
        case "tragedy": // 비극
            result = 40000;
            if (perf.audience > 30) {
                result += 1000 * (perf.audience - 30);
            }
            break;

        case "comedy": // 희극
            result = 30000;
            if (perf.audience > 20) {
                result += 10000 + 500 * (perf.audience - 20);
            }
            result  += 300 * perf.audience;
            break;
        
        default: 
            throw new Error(`알 수 없는 장르: ${play.type}`)
    }

    return result;
}
```

- 그 후 첫 번째 인수 perf -> aPerformance로 리팩터링
```Javascript
// perf -> aPerformance
function amountFor(aPerformance, play) {
    let result = 0;
    switch (play.type) {
        case "tragedy": // 비극
            result = 40000;
            if (aPerformance.audience > 30) {
                result += 1000 * (aPerformance.audience - 30);
            }
            break;

        case "comedy": // 희극
            result = 30000;
            if (aPerformance.audience > 20) {
                result += 10000 + 500 * (aPerformance.audience - 20);
            }
            result  += 300 * aPerformance.audience;
            break;
        
        default: 
            throw new Error(`알 수 없는 장르: ${play.type}`)
    }

    return result;
}
```
- 글쓴이는 매개변수 이름을 접두어로 타입 이름을 적는데, 매개변수의 역할이 뚜렷하지 않을 경우 부정관사(a/an)을 붙임

> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.

### play 변수 제거하기
- play 변수는 aPerformance 에서 얻기 때문에 매개변수로 전달할 필요가 없다. 
- 글쓴이는 긴 함수를 쪼갤 때마다 play 같은 변수를 최대한 제거한다. 
- 이 때 **임시 변수를 질의 함수로 바꾸기** 리팩터링을 사용한다. 

```Javascript
function playFor(aPerformance) {
    return plays[aPerformance.playID];
}
```

```Javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    
    const format = new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format;

    for (let perf of invoice.performances) {
        // playFor 함수로 변경해줌
        const play = playFor(perf);
        let thisAmount = amountFor(perf, play);

        volumeCredits += Math.max(perf.audience - 30, 0);
        // playFor함수로 변경
        if ('comedy' === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

        // playFor함수로 변경
        result += `  ${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience}석)\n`;
        totalAmount += thisAmount;
    }

    result += `총액: ${format(totalAmount/100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- 이후 **변수 인라인하기** 적용
```Javascript
        // 인라인된 변수 제거
        // const play = playFor(perf);
        let thisAmount = amountFor(perf, playFor(perf));
```

- **함수 선언 바꾸기**를 통한 play 매개변수 제거
```javascript
function amountFor(aPerformance, play) {
    let result = 0;
    // play -> playFor 함수로 변경
    switch (playFor(aPerformance).type) {
        case "tragedy": // 비극
            result = 40000;
            if (aPerformance.audience > 30) {
                result += 1000 * (aPerformance.audience - 30);
            }
            break;

        case "comedy": // 희극
            result = 30000;
            if (aPerformance.audience > 20) {
                result += 10000 + 500 * (aPerformance.audience - 20);
            }
            result  += 300 * aPerformance.audience;
            break;
        
        default: 
            // play -> playFor 함수로 변경
            throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`)
    }

    return result;
}
```

- play 매개변수 제거
```javascript
// play 매개변수 제거
function amountFor(aPerformance) {
    let result = 0;
    // play -> playFor 함수로 변경
    switch (playFor(aPerformance).type) {
        case "tragedy": // 비극
            result = 40000;
            if (aPerformance.audience > 30) {
                result += 1000 * (aPerformance.audience - 30);
            }
            break;

        case "comedy": // 희극
            result = 30000;
            if (aPerformance.audience > 20) {
                result += 10000 + 500 * (aPerformance.audience - 20);
            }
            result  += 300 * aPerformance.audience;
            break;
        
        default: 
            // play -> playFor 함수로 변경
            throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`)
    }

    return result;
}

function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    
    const format = new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format;

    for (let perf of invoice.performances) {
        // play 매개변수 제거
        let thisAmount = amountFor(perf);

        volumeCredits += Math.max(perf.audience - 30, 0);
        if ('comedy' === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

        // 청구 내역을 출력
        result += `  ${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience}석)\n`;
        totalAmount += thisAmount;
    }

    result += `총액: ${format(totalAmount/100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- 이전 코드는 루프를 한 번 돌 때마다 공연을 조회했는데 리팩터링한 코드는 세 번이나 조회함
    - 현재는 성능에 큰 영향이 없음, 그렇지만 추후에 성능을 개선하기 훨씬 수월해졌음
- amountFor() 는 임시 변수인 thisAmount에 값을 설정하는데 사용되는데 그 값이 다시 바뀌지 않음
    - **변수 인라인하기** 를 적용

```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    
    const format = new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format;

    for (let perf of invoice.performances) {
        volumeCredits += Math.max(perf.audience - 30, 0);
        if ('comedy' === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);

        // thisAmount 변수 인라인
        result += `  ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)\n`;
        // thisAmount 변수 인라인
        totalAmount += amountFor(perf);
    }

    result += `총액: ${format(totalAmount/100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

### 적입 포인트 계산 코드 추출하기
- `volumeCreditsFor(perf)` 함수로 함수 추출
- perf는 전달만 하면 되지만 volumeCredits 변수는 반복문을 돌 때마다 값을 누적해야 하기 때문에 살짝 까다롭다. 
    - 최선의 방법: volumeCredits의 복제본을 초기화한 뒤 계산 결과를 반환토록 하는 것

```Javascript
function volumeCreditsFor(perf) {
    let volumeCredits = 0;
    volumeCredits += Math.max(perf.audience - 30, 0);
    if ('comedy' === playFor(perf).type) {
        volumeCredits += Math.floor(perf.audience / 5);
    }
    return volumeCredits;
}

function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    
    const format = new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format;

    for (let perf of invoice.performances) {
        // 새로 추출한 함수를 이용해 값을 누적
        volumeCredits += volumeCreditsFor(perf);

        result += `  ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }

    result += `총액: ${format(totalAmount/100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- 변수 이름 변경
```Javascript
function volumeCreditsFor(aPerformance) {
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ('comedy' === playFor(aPerformance).type) {
        result += Math.floor(aPerformance.audience / 5);
    }
    return result;
}
```

### format 변수 제거하기
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;
    
    const format = new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format;

    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);

        result += `  ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }

    result += `총액: ${format(totalAmount/100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- 임시 변수는 나중에 문제를 일으킬 수 있다. 
- 그 중에 format은 임시 변수에 함수를 대입한 형태인데, 글쓴이는 직접 함수를 선언해 사용하도록 변경하는 편

```javascript
function format(aNumber) {
    return new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format(aNumber);
}

function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);

        result += `  ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }

    result += `총액: ${format(totalAmount/100)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- 함수의 이름이 하는 일을 충분히 설명해주지 못하는 것으로 보여 변경해주기 위해 **함수 선언 바꾸기** 를 적용했다.
    - 함수의 핵심은 화폐 단위 맞추기
```javascript
function usd(aNumber) {
    return new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format(aNumber / 100); // 단위 변환도 이쪽으로 옮김
}

function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);

        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }

    result += `총액: ${usd(totalAmount)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- 이름짓기는 중요하면서 쉽지 않은 작업, 긴 함수를 작게 쪼개는 리팩터링은 이름을 잘 지어야만 효과가 있다. 

### volumeCredits 변수 제거하기
- 이 변수는 반복문을 한 바퀴 돌 때마다 값을 누적하기 때문에 리팩터링하기 까다롭다. 
- 먼저 **반복문 쪼개기**로 volumeCredits 값이 누적되는 부분을 따로 추출

```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        // 청구 내역을 출력한다 
        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }
    // 값 누적 로직을 별도 for문으로 분리
    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);
    }

    result += `총액: ${usd(totalAmount)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- **문장 슬라이스하기** 를 적용해 volumeCredits 변수를 선언하는 문장을 반복문 앞으로 옮긴다. 
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        // 청구 내역을 출력한다 
        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }
    // 변수 선언을 반복문 앞으로 이동시킴
    let volumeCredits = 0;
    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);
    }

    result += `총액: ${usd(totalAmount)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- **임시 변수를 질의 함수로 바꾸기**가 수월하도록 코드가 변경되었음
- volumeCredits 값 계산 코드를 **함수 추출하기** 적용
```javascript
function totalVolumeCredits() {
    let volumeCredits = 0;
    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);
    }
    return volumeCredits;
}

function statement(invoice, plays) {
    let totalAmount = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }
    // 함수 추출로 변경
    let volumeCredits = totalVolumeCredits();

    result += `총액: ${usd(totalAmount)}\n`;
    result += `적립 포인트: ${volumeCredits}점\n`;

    return result;
}
```

- **변수 인라인** 적용
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
        totalAmount += amountFor(perf);
    }

    result += `총액: ${usd(totalAmount)}\n`;
    // 변수 인라인
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;

    return result;
}
```
- 반복문을 쪼개서 성능이 느려지지 않을까 걱정할 수 있다. 중복된 반복문을 꺼리는 이들이 많지만 이정도 중복은 성능에 미치는 옇양이 미미할 때가 많다.
- 리팩터링으로 인한 성능 문제에 대한 글쓴이의 조언은 **'특별한 경우가 아니라면 일단 무시하라'**
- 리팩터링 이 후에 성능을 또 개선하자.
>1. **반복문 쪼개기**로  변수 값을 누적시키는 부분을 분리
>2. **문장 슬라이드하기**로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮김
>3. **함수 추출하기**로 적립 포인트 계산 부분을 별도 함수로 추출
>4. **변수 인라인하기**로 volumeCredits 변수를 제거

- 다음으로 totalAmount도 똑같은 절차로 제거
```javascript
function appleSauce() {
    let totalAmount = 0;
    for (let perf of invoice.performances) {
        totalAmount += amountFor(perf);
    }
    return totalAmount;
}

function statement(invoice, plays) {
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }

    // 리팩터링
    result += `총액: ${usd(appleSauce())}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;

    return result;
}
```

-  함수 이름 변경 + 변수 이름 변경
```javascript
function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
        result += amountFor(perf);
    }
    return result;
}
```

## 1.5 중간 점검: 난무하는 중첩 함수
```javascript
function statement(invoice, plays) {
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }

    result += `총액: ${usd(totalAmount())}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;

    return result;

    function totalAmount() {
        let result = 0;
        for (let perf of invoice.performances) {
            result += amountFor(perf);
        }
        return result;
    }

    function totalVolumeCredits() {
        let result = 0;
        for (let perf of invoice.performances) {
            result += volumeCreditsFor(perf);
        }
        return result;
    }

    function usd(aNumber) {
        return new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format(aNumber / 100); 
    }

    function volumeCreditsFor(aPerformance) {
        let result = 0;
        result += Math.max(aPerformance.audience - 30, 0);
        if ('comedy' === playFor(aPerformance).type) {
            result += Math.floor(aPerformance.audience / 5);
        }
        return result;
    }

    function playFor(aPerformance) {
        return plays[aPerformance.playID];
    }

    function amountFor(aPerformance) {
        let result = 0;
        switch (playFor(aPerformance).type) {
            case "tragedy": // 비극
                result = 40000;
                if (aPerformance.audience > 30) {
                    result += 1000 * (aPerformance.audience - 30);
                }
                break;

            case "comedy": // 희극
                result = 30000;
                if (aPerformance.audience > 20) {
                    result += 10000 + 500 * (aPerformance.audience - 20);
                }
                result  += 300 * aPerformance.audience;
                break;
            
            default: 
                throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`)
        }

        return result;
    }
}
```

## 1.6 계산 단계와 포맷팅 단계 분리하기
- 지금까지는 프로그램의 논리적인 요소를 파악하기 쉽게 코드의 구조를 보강하는데 중점을 두고 리팩터링을 진행
- 이제 추가 요구사항인 HTML 버전을 만드는 작업 시작
    - **문제점**: 계산 함수들이 텍스트 버전인 statement() 안에 중첩 함수로 들어가 있음
    - 텍스트 버전과 html 버전 함수 모두가 똑같은 계산 함수들을 사용하게 만드는 것이 목표 
    - **해결책**: 단계 쪼개기
        1. statement() 함수에서 필요한 데이터를 처리하고
        2. 다음 단계에서 앞서 처리한 결과를 텍스트나 HTML로 표현

```javascript
function statement(invoice, plays) {
    // 본문 전체를 별도 함수로 추출
    return renderPlainText(invoice, plays); 
}

function renderPlainText(invoice, plays) {
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }

    result += `총액: ${usd(totalAmount())}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;

    return result;
}
```

- 다음으로 두 단계 사이의 중간 데이터 구조 역할을 할 객체를 만들어 renderPlainText() 에 인수로 전달한다. 
```javascript
function statement(invoice, plays) {
    const statementData = {};
    return renderPlainText(statementData, invoice, plays);
}

function renderPlainText(data, invoice, plays) {
    let result = `청구 내역 (고객명: ${invoice.customer})\n`;

    for (let perf of invoice.performances) {
        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }

    result += `총액: ${usd(totalAmount())}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;

    return result;

    // 아래엔 내부 함수 구현
}
```

- 고객 정보부터 객체로 옮겨보자
    - 이렇게 되면 invoice를 매개변수로 넘기지 않아도 된다. 
```javascript
function statement(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer;
    return renderPlainText(statementData, invoice, plays);
}

function renderPlainText(data, invoice, plays) {
    // 고객명을 data에서 얻어오도록 한다
    let result = `청구 내역 (고객명: ${data.customer})\n`;

    for (let perf of invoice.performances) {
        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }

    result += `총액: ${usd(totalAmount())}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;

    return result;

    // 아래엔 내부 함수 구현
}
```

- invoice 매개변수 삭제
```javascript
function statement(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer;
    statementData.performances = invoice.performances;
    return renderPlainText(statementData, plays);
}

function renderPlainText(data, plays) {
    let result = `청구 내역 (고객명: ${data.customer})\n`;
    // performances도 data에서 가져옴
    for (let perf of data.performances) {
        result += `  ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }

    result += `총액: ${usd(totalAmount())}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;

    return result;

    // 내부 함수에서 invoice 제거
    function totalAmount() {
        let result = 0;
        for (let perf of data.performances) {
            result += amountFor(perf);
        }
        return result;
    }

    function totalVolumeCredits() {
        let result = 0;
        for (let perf of data.performances) {
            result += volumeCreditsFor(perf);
        }
        return result;
    }

    function usd(aNumber) {
        return new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format(aNumber / 100); 
    }

    function volumeCreditsFor(aPerformance) {
        let result = 0;
        result += Math.max(aPerformance.audience - 30, 0);
        if ('comedy' === playFor(aPerformance).type) {
            result += Math.floor(aPerformance.audience / 5);
        }
        return result;
    }

    function playFor(aPerformance) {
        return plays[aPerformance.playID];
    }

    function amountFor(aPerformance) {
        let result = 0;
        switch (playFor(aPerformance).type) {
            case "tragedy": // 비극
                result = 40000;
                if (aPerformance.audience > 30) {
                    result += 1000 * (aPerformance.audience - 30);
                }
                break;

            case "comedy": // 희극
                result = 30000;
                if (aPerformance.audience > 20) {
                    result += 10000 + 500 * (aPerformance.audience - 20);
                }
                result  += 300 * aPerformance.audience;
                break;
            
            default: 
                throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`)
        }

        return result;
    }
}
```

- 연극 제목도 중간 데이터 구조에서 가져오도록 한다.
- 얕은 복사를 이용하는 이유는 불변처럼 데이터를 취급하기 위해서이다. 
```javascript
function statement(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer;
    statementData.performances = invoice.performances.map(enrichPerformance);
    return renderPlainText(statementData, plays);

    function enrichPerformance(aPerformance) {
        const result = Object.assign({}, aPerformance); // 얕은 복사 수행
        return result;
    }
}
```

- **함수 옮기기**를 통해 playFor 를 statement로 옮김
```javascript
function statement(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer;
    statementData.performances = invoice.performances.map(enrichPerformance);
    return renderPlainText(statementData, plays);

    function enrichPerformance(aPerformance) {
        const result = Object.assign({}, aPerformance); // 얕은 복사 수행
        result.play = playFor(result);
        return result;
    }

    function playFor(aPerformance) {
        return plays[aPerformance.playID];
    }
}

// playFor 써준 함수를 data.play를 접근하도록 수정
function renderPlainText(data, plays) {
    let result = `청구 내역 (고객명: ${data.customer})\n`;
    // performances도 data에서 가져옴
    for (let perf of data.performances) {
        result += `  ${perf.play.name}: ${usd(amountFor(perf))} (${perf.audience}석)\n`;
    }

    result += `총액: ${usd(totalAmount())}\n`;
    result += `적립 포인트: ${totalVolumeCredits()}점\n`;

    return result;

    // 내부 함수에서 invoice 제거
    function totalAmount() {
        let result = 0;
        for (let perf of data.performances) {
            result += amountFor(perf);
        }
        return result;
    }

    function totalVolumeCredits() {
        let result = 0;
        for (let perf of data.performances) {
            result += volumeCreditsFor(perf);
        }
        return result;
    }

    function usd(aNumber) {
        return new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format(aNumber / 100); 
    }

    function volumeCreditsFor(aPerformance) {
        let result = 0;
        result += Math.max(aPerformance.audience - 30, 0);
        if ('comedy' === aPerformance.play.type) {
            result += Math.floor(aPerformance.audience / 5);
        }
        return result;
    }

    function amountFor(aPerformance) {
        let result = 0;
        switch (aPerformance.play.type) {
            case "tragedy": // 비극
                result = 40000;
                if (aPerformance.audience > 30) {
                    result += 1000 * (aPerformance.audience - 30);
                }
                break;

            case "comedy": // 희극
                result = 30000;
                if (aPerformance.audience > 20) {
                    result += 10000 + 500 * (aPerformance.audience - 20);
                }
                result  += 300 * aPerformance.audience;
                break;
            
            default: 
                throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`)
        }

        return result;
    }
}
```

- amountFor() 함수, 적립 포인트 계산 부분 옮김, 총합 구하는 부분 옮김
- **반복문을 파이프라인으로 바꾸기** 까지 적용
- 파일 분리를 위해 함수명 변경까지 적용
```javascript
function statement(invoice, plays) {
    return renderPlainText(createStatementData(invoice, plays));
}

function createStatementData(invoice, plays) {
    const result = {};
    result.customer = invoice.customer;
    result.performances = invoice.performances.map(enrichPerformance);
    result.totalAmount = totalAmount(result);
    result.totalVolumeCredits = totalVolumeCredits(result);
    return result;

    function enrichPerformance(aPerformance) {
        const result = Object.assign({}, aPerformance); // 얕은 복사 수행
        result.play = playFor(result);
        result.amount = amountFor(result);
        result.volumeCredits = volumeCreditsFor(result);
        return result;
    }

    function amountFor(aPerformance) {
        let result = 0;
        switch (aPerformance.play.type) {
            case "tragedy": // 비극
                result = 40000;
                if (aPerformance.audience > 30) {
                    result += 1000 * (aPerformance.audience - 30);
                }
                break;

            case "comedy": // 희극
                result = 30000;
                if (aPerformance.audience > 20) {
                    result += 10000 + 500 * (aPerformance.audience - 20);
                }
                result  += 300 * aPerformance.audience;
                break;
            
            default: 
                throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`)
        }

        return result;
    }

    function totalAmount(data) {
        return data.performances.reduce((total, p) => total + p.amount, 0);
    }

    function totalVolumeCredits(data) {
        return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
    }

    function usd(aNumber) {
        return new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format(aNumber / 100); 
    }

    function volumeCreditsFor(aPerformance) {
        let result = 0;
        result += Math.max(aPerformance.audience - 30, 0);
        if ('comedy' === aPerformance.play.type) {
            result += Math.floor(aPerformance.audience / 5);
        }
        return result;
    }
}

function renderPlainText(data) {
    let result = `청구 내역 (고객명: ${data.customer})\n`;
    // performances도 data에서 가져옴
    for (let perf of data.performances) {
        result += `  ${perf.play.name}: ${usd(perf.amount)} (${perf.audience}석)\n`;
    }

    result += `총액: ${usd(data.totalAmount)}\n`;
    result += `적립 포인트: ${data.totalVolumeCredits}점\n`;

    return result;
}
```

- HTML 버전 작성
```javascript
function htmlStatement(invoice, plays) {
    return renderHtml(createStatementData(invoice, plays));
}

function renderHtml(data) {
    let result = `<h1>청구 내역 (고객명: ${data.customer})</h1>`;
    result += `<table>`;
    result += `<tr><th>연극</th><th>좌석 수</th><th>금액</th></tr>`;
    for (let perf of data.performances) {
        result += `<tr><td>${perf.play.name}</td><td>(${perf.audience}석)</td>`;
        result += `<td>${usd(perf.amount)}</td></tr>`;
    }
    result += `</table>`;
    result += `<p>총액: <em>${usd(data.totalAmount)}</em></p>`;
    result += `<p>적립 포인트: <em>${data.totalVolumeCredits}</em>점</p>`;
    return result;
}
```

## 1.7 중간 점검: 두 파일(과 두 단계)로 분리됨
#### statement.js
```javascript
function statement(invoice, plays) {
    return renderPlainText(createStatementData(invoice, plays));
}

function renderPlainText(data) {
    let result = `청구 내역 (고객명: ${data.customer})\n`;
    // performances도 data에서 가져옴
    for (let perf of data.performances) {
        result += `  ${perf.play.name}: ${usd(perf.amount)} (${perf.audience}석)\n`;
    }

    result += `총액: ${usd(data.totalAmount)}\n`;
    result += `적립 포인트: ${data.totalVolumeCredits}점\n`;

    return result;
}

function htmlStatement(invoice, plays) {
    return renderHtml(createStatementData(invoice, plays));
}

function renderHtml(data) {
    let result = `<h1>청구 내역 (고객명: ${data.customer})</h1>`;
    result += `<table>`;
    result += `<tr><th>연극</th><th>좌석 수</th><th>금액</th></tr>`;
    for (let perf of data.performances) {
        result += `<tr><td>${perf.play.name}</td><td>(${perf.audience}석)</td>`;
        result += `<td>${usd(perf.amount)}</td></tr>`;
    }
    result += `</table>`;
    result += `<p>총액: <em>${usd(data.totalAmount)}</em></p>`;
    result += `<p>적립 포인트: <em>${data.totalVolumeCredits}</em>점</p>`;
    return result;
}

function usd(aNumber) {
    return new Intl.NumberFormat("en-US", {style : "currency", currency: "USD", minimumFractionDigits: 2}).format(aNumber / 100); 
}
```

#### createStatement.js
```javascript
export default function createStatementData(invoice, plays) {
    const result = {};
    result.customer = invoice.customer;
    result.performances = invoice.performances.map(enrichPerformance);
    result.totalAmount = totalAmount(result);
    result.totalVolumeCredits = totalVolumeCredits(result);
    return result;

    function enrichPerformance(aPerformance) {
        const result = Object.assign({}, aPerformance); // 얕은 복사 수행
        result.play = playFor(result);
        result.amount = amountFor(result);
        result.volumeCredits = volumeCreditsFor(result);
        return result;
    }

    function amountFor(aPerformance) {
        let result = 0;
        switch (aPerformance.play.type) {
            case "tragedy": // 비극
                result = 40000;
                if (aPerformance.audience > 30) {
                    result += 1000 * (aPerformance.audience - 30);
                }
                break;

            case "comedy": // 희극
                result = 30000;
                if (aPerformance.audience > 20) {
                    result += 10000 + 500 * (aPerformance.audience - 20);
                }
                result  += 300 * aPerformance.audience;
                break;
            
            default: 
                throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`)
        }

        return result;
    }

    function playFor(aPerformance) {
        return plays[aPerformance.playID];
    }

    function totalAmount(data) {
        return data.performances.reduce((total, p) => total + p.amount, 0);
    }

    function totalVolumeCredits(data) {
        return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
    }

    function volumeCreditsFor(aPerformance) {
        let result = 0;
        result += Math.max(aPerformance.audience - 30, 0);
        if ('comedy' === aPerformance.play.type) {
            result += Math.floor(aPerformance.audience / 5);
        }
        return result;
    }
}
```

> 캠핑자들에게는 '도착했을 때보다 깔끔하게 정돈하고 떠난다' 는 규칙이 있다. 프로그래밍도 마찬가지다. 항상 코드베이스를 작업 시작 전보다 건강하게(healthy) 만들어놓고 떠나야 한다.

## 1.8 다형성을 활용해 계산 코드 재구성하기
- 이번엔 **연극 장르를 추가**하고 **장르마다 공연료와 적립 포인트 계산법을 다르게 지정**하도록 기능을 수정해보자. 
- amountFor() 함수의 조건문을 수정해야하는데 이때 다형성을 이용해 수정해보자.
- 공연료와 적립 포인트 계산 함수를 클래스를 정의한다. 

### 공연료 계산기 만들기
- createStatement.js 
```javascript
...
    function enrichPerformance(aPerformance) {
        const calculator = new PerformanceCalculator(aPerformance);
        const result = Object.assign({}, aPerformance);
        result.play = playFor(result);
        result.amount = amountFor(result);
        result.volumeCredits = volumeCreditsFor(result);
        return result;
    }
...

class PerformanceCalculator {
    constructor(aPerformance) {
        this.performance = aPerformance;
    }
}
```

- 연극 레코드부터 동작을 이 클래스로 옮겨보도록 한다. (**함수 선언 바꾸기**)
```javascript
    function enrichPerformance(aPerformance) {
        const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance));
        const result = Object.assign({}, aPerformance);
        result.play = calculator.play;
        result.amount = amountFor(result);
        result.volumeCredits = volumeCreditsFor(result);
        return result;
    }

class PerformanceCalculator {
    constructor(aPerformance, aPlay) {
        this.performance = aPerformance;
        this.play = aPlay;
    }
}    
```

### 함수들을 계산기로 옮기기
- 이번엔 함수를 다른 컨텍스트로 옮기는 큰 작업이기 때문에 단계별로 차근차근 진행하도록 한다. 

```javascript
class PerformanceCalculator {
    constructor(aPerformance, aPlay) {
        this.performance = aPerformance;
        this.play = aPlay;
    }

    get amount() {
        let result = 0;
        switch (this.play.type) {
            case "tragedy": // 비극
                result = 40000;
                if (this.performance.audience > 30) {
                    result += 1000 * (this.performance.audience - 30);
                }
                break;

            case "comedy": // 희극
                result = 30000;
                if (this.performance.audience > 20) {
                    result += 10000 + 500 * (this.performance.audience - 20);
                }
                result  += 300 * this.performance.audience;
                break;
            
            default: 
                throw new Error(`알 수 없는 장르: ${this.play.type}`)
        }

        return result;
    }
}   

// amountFor 수정
function amountFor(aPerformance) {
    return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount;
}
```

- **함수 인라인**하기
```javascript
    function enrichPerformance(aPerformance) {
        const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance));
        const result = Object.assign({}, aPerformance);
        result.play = calculator.play;
        result.amount = calculator.amount;
        result.volumeCredits = volumeCreditsFor(result);
        return result;
    }
```

- volumeCredits 함수도 같은 방법으로 옮긴다.
```javascript
class PerformanceCalculator {
    get volumeCredits() {
        let result = 0;
        result += Math.max(this.performance.audience - 30, 0);
        if ('comedy' === this.performance.play.type) {
            result += Math.floor(this.performance.audience / 5);
        }
        return result;
    }
}

    function enrichPerformance(aPerformance) {
        const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance));
        const result = Object.assign({}, aPerformance);
        result.play = calculator.play;
        result.amount = calculator.amount;
        result.volumeCredits = calculator.volumeCredits;
        return result;
    }
```

### 공연료 계산기를 다형성 버전으로 만들기
- 가장 먼저 할 일은 타입코드 대신 서브클래스를 사용하도록 변경 (**타입 코드를 서브클래스로 바꾸기**)
    - PerformanceCalculator의 서브클래스들을 준비하고 createStatementData()에서 그 중 적합한 서브 클래스를 사용하게 만들어야 한다.
    - 생성자 대신 함수를 호출하도록 바꿔야한다 (**생성자를 팩터리 함수로 바꾸기**)

```javascript
function enrichPerformance(aPerformance) {
    const calculator = createPerformanceCalculator(aPerformance, playFor(aPerformance));
    const result = Object.assign({}, aPerformance);
    result.play = calculator.play;
    result.amount = calculator.amount;
    result.volumeCredits = calculator.volumeCredits;
    return result;
}

function createPerformanceCalculator(aPerformance, aPlay) {
    return new PerformanceCalculator(aPerformance, aPlay);
}
```

- 팩터리 함수를 사용하면 서브클래스 중에 어떤걸 생성해서 반환할 지 선택할 수 있다.
```javascript
function createPerformanceCalculator(aPerformance, aPlay) {
    switch (aPlay.type) {
        case "tragedy": return new TragedyCalculator(aPerformance, aPlay);
        case "comedy": return new ComedyCalculator(aPerformance, aPlay);
        default:
            throw new Error(`알 수 없는 장르:${aPlay.type}`);
    }
}

class TragedyCalculator extends PerformanceCalculator {}
class ComedyCalculator extends PerformanceCalculator {}
```

- **조건부 로직을 다형성으로 바꾸기** 적용
```javascript
class TragedyCalculator extends PerformanceCalculator {
    get amount() {
        let result = 40000;
        if (this.performance.audience > 30) {
            result += 1000 * (this.performance.audience - 30);
        }
        return result;
    }
}

class ComedyCalculator extends PerformanceCalculator {
    get amount() {
        let result = 30000;
        if (this.performance.audience > 20) {
            result += 10000 + 500 * (this.performance.audience - 20);
        }
        result += 300 * this.performance.audience;
        return result;
    }

    get volumeCredits() {
        return super.volumeCredits + Math.floor(this.performance.audience / 5);
    }
}

class PerformanceCalculator {
    constructor(aPerformance, aPlay) {
        this.performance = aPerformance;
        this.play = aPlay;
    }

    get amount() {
        throw new Error('서브 클래스에서 처리하도록 설계되었습니다.');
    }

    get volumeCredits() {
        return Math.max(this.performance.audience - 30 , 0);
    }
}
```

## 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기
#### createStatementData.js
```javascript
export default function createStatementData(invoice) {
    const result = {};
    result.customer = invoice.customer;
    result.performances = invoice.performances.map(enrichPerformance);
    result.totalAmount = totalAmount(result);
    result.totalVolumeCredits = totalVolumeCredits(result);
    return result;

    function enrichPerformance(aPerformance) {
        const calculator = createPerformanceCalculator(aPerformance, playFor(aPerformance));
        const result = Object.assign({}, aPerformance);
        result.play = calculator.play;
        result.amount = calculator.amount;
        result.volumeCredits = calculator.volumeCredits;
        return result;
    }

    function playFor(aPerformance) {
        return plays[aPerformance.playID];
    }

    function totalAmount(data) {
        return data.performances.reduce((total, p) => total + p.amount, 0);
    }

    function totalVolumeCredits(data) {
        return data.performances.reduce((total, p) => total + p.volumeCredits, 0);
    }
}

function createPerformanceCalculator(aPerformance, aPlay) {
    switch (aPlay.type) {
        case "tragedy": return new TragedyCalculator(aPerformance, aPlay);
        case "comedy": return new ComedyCalculator(aPerformance, aPlay);
        default:
            throw new Error(`알 수 없는 장르:${aPlay.type}`);
    }
}

class TragedyCalculator extends PerformanceCalculator {
    get amount() {
        let result = 40000;
        if (this.performance.audience > 30) {
            result += 1000 * (this.performance.audience - 30);
        }
        return result;
    }
}

class ComedyCalculator extends PerformanceCalculator {
    get amount() {
        let result = 30000;
        if (this.performance.audience > 20) {
            result += 10000 + 500 * (this.performance.audience - 20);
        }
        result += 300 * this.performance.audience;
        return result;
    }

    get volumeCredits() {
        return super.volumeCredits + Math.floor(this.performance.audience / 5);
    }
}

class PerformanceCalculator {
    constructor(aPerformance, aPlay) {
        this.performance = aPerformance;
        this.play = aPlay;
    }

    get amount() {
        throw new Error('서브 클래스에서 처리하도록 설계되었습니다.');
    }

    get volumeCredits() {
        return Math.max(this.performance.audience - 30 , 0);
    }
}
```

- 새로운 장르를 추가하려면 해당 장르의 서브클래스를 작성하고 생성 함수인 createPerformanceCalculator()에 추가하기만 하면 된다. 

## 1.10 마치며
- 이번 장에선 아래와 같은 리팩터링 기법을 확인할 수 있었다. 
    - 함수 추출하기
    - 변수 인라인 하기
    - 함수 옮기기
    - 조건부 로직을 다형성으로 바꾸기

- 리팩터링을 크게 세 단계로 진행했다.
    - 원본 함수를 중첩 함수 여러 개로 나눔
    - 단계 쪼개기를 적용해 계산 코드와 출력 코드 분리
    - 계산 로직을 다형성으로 표현

> 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.
