# 테스트 구축하기

## 4.1 자가 테스트 코드의 가치

* 프로그래머들이  대부분의 시간을  디버깅하는데 사용함
* 버그 수정자체는 대체로 금방 끝난다. 진짜 끔찍한 것음 버그를 찾는여정이다.
* 자가 테스트 소프트웨어 
  * 모든 테스트를 완전히 자동화 하고 그 결과까지 스스로 검사하게 만들자
* 테스트를 자주 수행하는 습관도 버그를 찾는 강력한 도구
* 테스트 스위트는 강력한 버그 검출 도구로 버그를 찾는데 걸리는 시간을 대폭 줄여준다.
  * 테스트 스위트 : 테스트 대상 컴포넌트나 시스템에 사용되는 여러 테스트 케이스의 집합. 
  * 테스트 스위트는 테스트 사후조건이 주로 다음 테스트를 위한 사전조건이 되는 테스트 케이스로 구성된다.
* JUnit : 자가 테스트 코드를 작성하고 구성하는 수고를 덜어주는 도구
* 테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전
* TDD : 테스트 주도 개발 기법

## 4.2 테스트할 샘플 코드

* 테스트 대상 코드 : 사용자가 생산 계획을 검토하고 수정하돌고 해주는 간단한 어플리케이션
* 비지니스 로직코드
  * Producer : 생산자를 표현
  * Province : 지역 전체를 표현 (생성자는 JSON 문서로 부터 만들어진 자바스크립트 객체를 받음) 
* sampleProvinceData() 함수 ; Province 의 생성자 인수로 쓸 JSON객체 생성)

## 4.3 첫번째 테스트

* 테스트 프레임워크 : Mocha

* 픽스처(고정장치) : 테스트에 필요한 데이터와 개체

* 생산부족분을 제대로 계산하는지 확인하는 테스트

  describe('province', function () {

    it('shortfall', function () {

  ​	const asia = new Province(sampleProvinceData()); // 픽스처 설정

  ​    assert.equal(asia.shortfall, 5); // 검증
    });

  });

* 실패 할 상황에서는 반드시 실패하게 만들자

  * 일시적으로 오류를 주입하여 각각의 테스트가 실패하는 모습을 최소한 한번 씩 확인

* 자주 테스트 하라. 작성중인 코드는 최소한 몇 분 간격으로 테스트 하고 적어도 하루에 한번은 전체 테스트를 돌려보자

* 모카 프레임워크는 검증라이브러리 선택 가능 (이 책에서는 Chai 사용)

* assertion 또는 expect 사용

  describe('province', function () {

    it('shortfall', function () {

  ​	const asia = new Province(sampleProvinceData()); // 픽스처 설정

  ​    expect(asia.shortfall).equal(5); // 검증
    });

  });

* GUI 테스트 러너가 편하지만 반드시 필요한 것은 아니다. 핵심은 모든 테스트가 통과했다는사실을 빨리 알 수 있다는 데 있다.

## 4.4 테스트 추가하기

* 클래스가 하는 일을 모두 살펴보고 각각의 기능에서 오류가 생길 수 있는 조건을 하나씩 테스트 하는 식으로 진행

* 완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다.

* 초기 픽스처로 부터 총수익이 제대로 계산되는지 검사하는 테스트 추가
  describe('province', function () {

   it('shortfall', function () {

  ​	const asia = new Province(sampleProvinceData()); // 픽스처 설정

  ​    expect(asia.shortfall).equal(5); // 검증
    });

   it('profit', function () {

  ​	const asia = new Province(sampleProvinceData()); // 픽스처 설정

  ​    expect(asia.profit).equal(230); // 검증
    });

  });

* 똑같은 픽스처 설정하는 중복코드 제거 

  describe('province', function () {
   const asia = new Province(sampleProvinceData()); //  이렇게 하면 절대 안됨

    it('shortfall', function () {

  ​    expect(asia.shortfall).equal(5); // 검증
    });

   it('profit', function () {

  ​    expect(asia.profit).equal(230); // 검증
    });

  });

* 위와 같이 하면 안됨. 테스트끼리 상호작용하게 하는 공유 픽스처를 생성하는 원인이 됨

* 다음과 같은 방식 선호

  describe('province', function () {  let asia;
    beforeEach(function () {
      asia = new Province(sampleProvinceData());
    });

    it('shortfall', function () {

  ​    expect(asia.shortfall).equal(5); // 검증
    });

   it('profit', function () {

  ​    expect(asia.profit).equal(230); // 검증
    });

  });

* beforeEach 구문은 각각의 테스트 바로 전에 실행되어 asia를 초기화

  * 매번 픽스처를 생겅하느라 느려지는 경우는 거의 없음
  * 정말 문제가 될 때는 공유 픽스처 사용
    * 어떤 테스트도 픽스처 값을 변경하지 못하도록 주의
    * 불변임이 확실한 픽스처는 공유하기도 함
  * 그래도 가장 선호하는 방법은 매번 새로운 픽스처를 만드는 것

* beforeEach의 등장은 내가 ㅍ준 픽스처를 사용하다는 사실을 알려줌

## 4.5 픽스처 수정하기

* 실전에서는 픽스처의 내용이 수정되는 경우가 흔하다.

* 단순한 세터는 테스트하지 않지만 Producer 의 production() 세터는 복잡한 동작을 수행하므로 테스트 필요

  describe('province', ...  it('change production', function () {
      asia.producers[0].production = 20;

  ​	expect(asia.shortfall).equal(-6);

  ​	expect(asia.profit).equal(292)

    });

  * 흔히 보는 패턴임 
  * 설정-실행-검증, 조건-발생-결과, 준비-수행-단언 등으로 부름
  * 이 테스트는 두 속성을 검증하고 있으나 일반적으로 it구문 하나당 하나씩만 검증하는 것이 좋음
    * 앞쪽 검증을 통과하지 못하면 나머지 검증은 실행해 보지도 못하고 테스트가 실패 하여 원인파악에 필요한 정보를 놓치기 쉬움

## 4.6 경계 조건 검사하기

* 모든 일이 순조롭고 사용자도 우리 의도대로 사용하는 일명 '꽃길 상황'에서 벗어나는 경계 지점에서 문제가 생기면 어떤일이 벌어지는지 확인하는 테스트도 함께 작성하면 좋다.

* 컬렉션이 비었을 때 확인

* 숫자형이라면 0 일 때 검사, 음수도 넣어본다.

* UI로부터 문자열을 취하고 있다보니 필드가 아예 비어 있을 때도 태스트

* 문제가 생길 가능성이  있는 경계 조건을 생각해 보고 그부분을 집중적으로 테스트 하라.

* 의식적으로 프로그램을 망가뜨리는 방법을 모색

* 흥미로운 테스트

  * 수 필드에 문자열 대임시 에러가 발생하여 실패로 처리
  * 모카는 이 경우 실패로 처리
  * 에러와 실패를 구분하는 프레임워크도 많이 있음
  * 이 상황에서의 대응
    * 에러상황을 지금보다 잘 처리하도록 코드를 추가
    * 더 의미 있는 오류 메세지를 출력
    * 그냥 로그 메세지만 남김
    * 지금 상태(오류메세지 발생)대로 남겨 둠 
      * 예를 들어 입력객체를 신뢰할 수 있는 곳에서 만들어주는 경우
      * 같은 코드베이스의 모듈 사이에 유효성 감사 코드가 너무 많으면 중복 검증 발생
      * JSON과 같이 외부에서 들어온 객체는 유효한지 확인해 봐야 하므로 테스트를 작성해야함

  * 리팩토링 전이라면 이런 테스트 코드를 작성하지 않을 것이다(?)
    * 리팩토링은 겉보기 동작에 영향을 주지 않아야 함
    * 이러한 오류는 겉보기 동작에 해당하지 않음
    *  따라서 경계조건에 대응하는 동작이 리패터링 때문에 변하는지는 신경 쓸 필요가 없다.
  * 이러한 오류로 디버깅하기가 어렵다면 어서션 추가하기로 최대한 오류가 빨리 드러나게 하자
  * 어서션도 일종의  테스트 이므로 테스트코드를 따로 작성할 필요가 없다.
  * 어느 수준까지 테스트를 해야할까?
    *  수확 체감 범칙
      * 자본과 노동 등 생산요소가 한 단위 추가될 때 이로 인해 늘어나는 한계생산량은 점차 줄어든다는 것을 의미한다. 
      * 즉 생산요소를 추가적으로 계속 투입해 나갈 때 어느 시점이 지나면 새롭게 투입하는 요소로 인해 발생하는 수확의 증가량은 감소한다는 것
    * 위험한 부분에 집중
    * 코드에서 처리 과정이 복잡한 부분
    * 함수에서 오류가 생길만한 부분
  * 리팩토링하기 전에 테스트 스위트 부터 갖추지만 리팩토링 동안에도 계속 테스트를 추가한다

## 4.7 끝나지 않은 여정

* 이 책의 주제는 테스트가 아니느 리팩토링이다
* 테스트는 리팩터링에 반드시 필요한 토대
* 버그 리포트를 받으면 가장 먼저 그 버그를 드러내는 단위 테스트 부터 작성하자
* 테스트 커버러지는 테스트하지 않은 영역을 찾는데 도움이 될 뿐 테스트 스위트의 품질과는 상관없다.
* 테스트 스위트가 충분한지를 평가하는기준은 주관적이다.
  * 가령 ' 누군가 결함을 심으면 테스트가 발견할 수 있다는 믿음'을 기준으로 할 수 있다.
* 자가 테스트 코드의 목적은 이 믿음을 가지개 하는 것
* 테스트를 너무 많이 작성할 가능성도 있음
  * 제품코드보다 테스트 코드를 수정하는데 시간이 더 걸린다면
  * 테스트 때문에 개발속도가 느려진다고 생각되면
* 하지만 너무 많은 경우보다 너무 적은 경우가 훨씬 많다
